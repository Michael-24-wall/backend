class EnterpriseChat {
    constructor() {
        this.socket = null;
        this.currentRoom = null;
        this.user = null;
        this.typingTimer = null;
        this.typingUsers = new Set();
        
        this.initializeApp();
    }
    
    async initializeApp() {
        await this.loadUserInfo();
        await this.loadRooms();
        this.setupEventListeners();
    }
    
    async loadUserInfo() {
        try {
            const response = await fetch('/api/chat/profile/');
            if (!response.ok) throw new Error('Failed to fetch user info');
            const data = await response.json();
            this.user = data;
            document.getElementById('userInfo').innerHTML = `
                <p>Welcome, <strong>${data.user.username}</strong></p>
            `;
        } catch (error) {
            console.error('Failed to load user info:', error);
            document.getElementById('userInfo').innerHTML = `
                <p>Welcome, <strong>User</strong></p>
            `;
        }
    }
    
    async loadRooms() {
        try {
            const response = await fetch('/api/chat/rooms/');
            if (!response.ok) throw new Error('Failed to fetch rooms');
            const rooms = await response.json();
            this.renderRooms(rooms.results || rooms);
        } catch (error) {
            console.error('Failed to load rooms:', error);
            // Show default rooms if API fails
            this.renderRooms([
                { name: 'general', title: 'General Chat', member_count: 1, online_count: 1 },
                { name: 'random', title: 'Random Discussion', member_count: 1, online_count: 1 }
            ]);
        }
    }
    
    renderRooms(rooms) {
        const roomList = document.getElementById('roomList');
        roomList.innerHTML = rooms.map(room => `
            <div class="room-item" data-room="${room.name}" onclick="chat.joinRoom('${room.name}')">
                <strong>${room.title}</strong>
                <div style="font-size: 12px; opacity: 0.8;">
                    ${room.member_count} members â€¢ ${room.online_count} online
                </div>
            </div>
        `).join('');
    }
    
    async joinRoom(roomName) {
        // Leave current room
        if (this.socket) {
            this.socket.close();
        }
        
        this.currentRoom = roomName;
        
        // Update UI
        document.querySelectorAll('.room-item').forEach(item => {
            item.classList.remove('active');
        });
        const roomElement = document.querySelector(`[data-room="${roomName}"]`);
        if (roomElement) {
            roomElement.classList.add('active');
        }
        
        // Update header
        document.getElementById('currentRoom').textContent = `Room: ${roomName}`;
        document.getElementById('inputArea').style.display = 'block';
        
        // Clear messages
        document.getElementById('messagesContainer').innerHTML = '';
        
        // Load room messages
        await this.loadRoomMessages(roomName);
        
        // Connect to WebSocket
        this.connectWebSocket(roomName);
    }
    
    async loadRoomMessages(roomName) {
        try {
            const response = await fetch(`/api/chat/messages/?room=${roomName}`);
            if (response.ok) {
                const data = await response.json();
                const messages = data.results || data;
                this.renderMessages(messages);
            }
        } catch (error) {
            console.error('Failed to load messages:', error);
        }
    }
    
    connectWebSocket(roomName) {
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${window.location.host}/ws/chat/${roomName}/`;
        
        this.socket = new WebSocket(wsUrl);
        
        this.socket.onopen = () => {
            console.log('WebSocket connected successfully');
            this.addSystemMessage('Connected to chat room');
        };
        
        this.socket.onmessage = (event) => {
            const data = JSON.parse(event.data);
            this.handleWebSocketMessage(data);
        };
        
        this.socket.onclose = () => {
            console.log('WebSocket disconnected');
            this.addSystemMessage('Disconnected from chat');
        };
        
        this.socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.addSystemMessage('Connection error');
        };
    }
    
    handleWebSocketMessage(data) {
        switch (data.type) {
            case 'message':
                this.addMessage(data);
                break;
            case 'user_presence':
                this.handleUserPresence(data);
                break;
            case 'typing_indicator':
                this.handleTypingIndicator(data);
                break;
            case 'system_message':
                this.addSystemMessage(data.message);
                break;
            case 'error':
                this.addSystemMessage(`Error: ${data.error}`, true);
                break;
            default:
                console.log('Unknown message type:', data);
        }
    }
    
    addMessage(data) {
        const messagesContainer = document.getElementById('messagesContainer');
        const isOwnMessage = data.user_id === this.user?.user?.id;
        
        const messageElement = document.createElement('div');
        messageElement.className = `message ${isOwnMessage ? 'own' : 'other'}`;
        messageElement.innerHTML = `
            <div class="message-header">
                <strong>${data.username}</strong>
            </div>
            <div class="message-content">${this.escapeHtml(data.content)}</div>
            <div class="message-time">${this.formatTime(data.timestamp)}</div>
        `;
        
        messagesContainer.appendChild(messageElement);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    addSystemMessage(message, isError = false) {
        const messagesContainer = document.getElementById('messagesContainer');
        const messageElement = document.createElement('div');
        messageElement.className = 'message';
        messageElement.style.cssText = `
            background: ${isError ? '#ffebee' : '#e3f2fd'};
            color: ${isError ? '#c62828' : '#1565c0'};
            margin: 10px auto;
            text-align: center;
            font-style: italic;
        `;
        messageElement.textContent = message;
        
        messagesContainer.appendChild(messageElement);
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    handleUserPresence(data) {
        const presenceElement = document.getElementById('userPresence');
        let message = '';
        
        switch (data.action) {
            case 'joined':
                message = `ðŸŸ¢ ${data.username} joined the chat`;
                break;
            case 'left':
                message = `ðŸ”´ ${data.username} left the chat`;
                break;
        }
        
        if (message) {
            this.addSystemMessage(message);
        }
        
        // Update online count in room list
        if (data.online_count !== undefined) {
            const roomElement = document.querySelector(`[data-room="${this.currentRoom}"]`);
            if (roomElement) {
                const infoDiv = roomElement.querySelector('div');
                if (infoDiv) {
                    const match = infoDiv.textContent.match(/(\d+) members/);
                    if (match) {
                        infoDiv.innerHTML = `${match[1]} members â€¢ ${data.online_count} online`;
                    }
                }
            }
        }
    }
    
    handleTypingIndicator(data) {
        const typingElement = document.getElementById('typingIndicator');
        
        if (data.is_typing) {
            this.typingUsers.add(data.username);
        } else {
            this.typingUsers.delete(data.username);
        }
        
        if (this.typingUsers.size > 0) {
            const users = Array.from(this.typingUsers);
            let message = '';
            if (users.length === 1) {
                message = `${users[0]} is typing...`;
            } else if (users.length === 2) {
                message = `${users[0]} and ${users[1]} are typing...`;
            } else {
                message = `${users.slice(0, -1).join(', ')}, and ${users[users.length - 1]} are typing...`;
            }
            typingElement.textContent = message;
            typingElement.style.display = 'block';
        } else {
            typingElement.style.display = 'none';
        }
    }
    
    sendMessage() {
        const messageInput = document.getElementById('messageInput');
        const content = messageInput.value.trim();
        
        if (!content || !this.socket || this.socket.readyState !== WebSocket.OPEN) {
            return;
        }
        
        const messageData = {
            type: 'message',
            content: content
        };
        
        this.socket.send(JSON.stringify(messageData));
        messageInput.value = '';
        this.adjustTextareaHeight(messageInput);
        
        // Stop typing indicator
        this.sendTypingStop();
    }
    
    sendTypingStart() {
        if (this.socket && this.socket.readyState === WebSocket.OPEN) {
            this.socket.send(JSON.stringify({
                type: 'typing_start'
            }));
        }
    }
    
    sendTypingStop() {
        if (this.socket && this.socket.readyState === WebSocket.OPEN) {
            this.socket.send(JSON.stringify({
                type: 'typing_stop'
            }));
        }
    }
    
    setupEventListeners() {
        const messageInput = document.getElementById('messageInput');
        
        // Send message on Enter key (but allow Shift+Enter for new line)
        messageInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                this.sendMessage();
            }
        });
        
        // Auto-resize textarea
        messageInput.addEventListener('input', () => {
            this.adjustTextareaHeight(messageInput);
        });
        
        // Typing indicators
        messageInput.addEventListener('input', () => {
            if (messageInput.value.trim()) {
                this.sendTypingStart();
                clearTimeout(this.typingTimer);
                this.typingTimer = setTimeout(() => {
                    this.sendTypingStop();
                }, 1000);
            } else {
                this.sendTypingStop();
            }
        });
        
        // Handle window close
        window.addEventListener('beforeunload', () => {
            if (this.socket) {
                this.socket.close();
            }
        });
    }
    
    adjustTextareaHeight(textarea) {
        textarea.style.height = 'auto';
        textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }
    
    renderMessages(messages) {
        const messagesContainer = document.getElementById('messagesContainer');
        messagesContainer.innerHTML = '';
        
        messages.forEach(message => {
            const isOwnMessage = message.user?.id === this.user?.user?.id;
            const messageElement = document.createElement('div');
            messageElement.className = `message ${isOwnMessage ? 'own' : 'other'}`;
            messageElement.innerHTML = `
                <div class="message-header">
                    <strong>${message.username || message.user?.username}</strong>
                </div>
                <div class="message-content">${this.escapeHtml(message.content)}</div>
                <div class="message-time">${this.formatTime(message.timestamp)}</div>
            `;
            messagesContainer.appendChild(messageElement);
        });
        
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
    
    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    formatTime(timestamp) {
        if (!timestamp) return '';
        const date = new Date(timestamp);
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
}

// Initialize the chat application when the page loads
let chat;
document.addEventListener('DOMContentLoaded', () => {
    chat = new EnterpriseChat();
});

// Global function for room joining (for onclick handlers)
function joinRoom(roomName) {
    if (chat) {
        chat.joinRoom(roomName);
    }
}
</script>
</body>
</html>